{
    "queue": "type STRUCTNAME struct { buf []DATATYPE1; head, tail, sz, bm, l int }\nfunc NewSTRUCTNAME() *STRUCTNAME { buf := make([]DATATYPE1, 8); return &STRUCTNAME{buf, 0, 0, 8, 7, 0} }\nfunc (q *STRUCTNAME) IsEmpty() bool { return q.l == 0 }\nfunc (q *STRUCTNAME) Clear() { q.head = 0; q.tail = 0; q.l = 0 }\nfunc (q *STRUCTNAME) Len() int { return q.l }\nfunc (q *STRUCTNAME) Push(x DATATYPE1) {\n\tif q.l == q.sz { q.sizeup() }; if q.l > 0 { q.head = (q.head - 1) & q.bm }; q.l++; q.buf[q.head] = x\n}\nfunc (q *STRUCTNAME) Pop() DATATYPE1 {\n\tif q.l == 0 { panic(\"Empty STRUCTNAME Pop()\") }; v := q.buf[q.tail]; q.l--\n\tif q.l > 0 { q.tail = (q.tail - 1) & q.bm } else { q.Clear() }; return v\n}\nfunc (q *STRUCTNAME) Head() DATATYPE1 { if q.l == 0 { panic(\"Empty STRUCTNAME Head()\") }; return q.buf[q.head] }\nfunc (q *STRUCTNAME) Tail() DATATYPE1 { if q.l == 0 { panic(\"Empty STRUCTNAME Tail()\") }; return q.buf[q.tail] }\nfunc (q *STRUCTNAME) sizeup() {\n\tbuf := make([]DATATYPE1, 2*q.sz); for i := 0; i < q.l; i++ { buf[i] = q.buf[(q.head+i)&q.bm] }; q.buf = buf\n\tq.head = 0; q.tail = q.sz - 1; q.sz = 2 * q.sz; q.bm = q.sz - 1\n}",
    "stack": "type STRUCTNAME struct { buf []DATATYPE1; l int }\nfunc NewSTRUCTNAME() *STRUCTNAME { buf := make([]DATATYPE1, 0); return &STRUCTNAME{buf, 0} }\nfunc (q *STRUCTNAME) IsEmpty() bool { return q.l == 0 }\nfunc (q *STRUCTNAME) Clear() { q.buf = q.buf[:0]; q.l = 0 }\nfunc (q *STRUCTNAME) Len() int { return q.l }\nfunc (q *STRUCTNAME) Push(x DATATYPE1) { q.buf = append(q.buf, x); q.l++ }\nfunc (q *STRUCTNAME) Pop() DATATYPE1 {\n\tif q.l == 0 { panic(\"Empty STRUCTNAME Pop()\") }; v := q.buf[q.l-1]; q.l--; q.buf = q.buf[:q.l]; return v\n}\nfunc (q *STRUCTNAME) Head() DATATYPE1 { if q.l == 0 { panic(\"Empty STRUCTNAME Head()\") }; return q.buf[q.l-1] }\nfunc (q *STRUCTNAME) Top() DATATYPE1 { return q.Head() }",
    "deque": "type STRUCTNAME struct { buf []DATATYPE1; head, tail, sz, bm, l int }\nfunc NewSTRUCTNAME() *STRUCTNAME { buf := make([]DATATYPE1, 8); return &STRUCTNAME{buf, 0, 0, 8, 7, 0} }\nfunc (q *STRUCTNAME) IsEmpty() bool { return q.l == 0 }\nfunc (q *STRUCTNAME) Clear() { q.head = 0; q.tail = 0; q.l = 0 }\nfunc (q *STRUCTNAME) PushFront(x DATATYPE1) {\n\tif q.l == q.sz { q.sizeup() }; if q.l > 0 { q.head = (q.head - 1) & q.bm }; q.l++; q.buf[q.head] = x\n}\nfunc (q *STRUCTNAME) PushBack(x DATATYPE1) {\n\tif q.l == q.sz { q.sizeup() }; if q.l > 0 { q.tail = (q.tail + 1) & q.bm }; q.l++; q.buf[q.tail] = x\n}\nfunc (q *STRUCTNAME) PopFront() DATATYPE1 {\n\tif q.l == 0 { panic(\"Empty STRUCTNAME PopFront()\") }; v := q.buf[q.head]; q.l--\n\tif q.l > 0 { q.head = (q.head + 1) & q.bm } else { q.Clear() }; return v\n}\nfunc (q *STRUCTNAME) PopBack() DATATYPE1 {\n\tif q.l == 0 { panic(\"Empty STRUCTNAME PopBack()\") }; v := q.buf[q.tail]; q.l--\n\tif q.l > 0 { q.tail = (q.tail - 1) & q.bm } else { q.Clear() }; return v\n}\nfunc (q *STRUCTNAME) Len() int { return q.l }\nfunc (q *STRUCTNAME) Head() DATATYPE1 { if q.l == 0 { panic(\"Empty STRUCTNAME Head()\") }; return q.buf[q.head] }\nfunc (q *STRUCTNAME) Tail() DATATYPE1 { if q.l == 0 { panic(\"Empty STRUCTNAME Tail()\") }; return q.buf[q.tail] }\nfunc (q *STRUCTNAME) sizeup() {\n\tbuf := make([]DATATYPE1, 2*q.sz); for i := 0; i < q.l; i++ { buf[i] = q.buf[(q.head+i)&q.bm] }; q.buf = buf\n\tq.head = 0; q.tail = q.sz - 1; q.sz = 2 * q.sz; q.bm = q.sz - 1\n}",
    "minheap": "type STRUCTNAME struct { buf []DATATYPE1; less func(DATATYPE1, DATATYPE1) bool }\nfunc NewSTRUCTNAME(f func(DATATYPE1, DATATYPE1) bool) *STRUCTNAME { buf := make([]DATATYPE1, 0); return &STRUCTNAME{buf, f} }\nfunc (q *STRUCTNAME) IsEmpty() bool { return len(q.buf) == 0 }\nfunc (q *STRUCTNAME) Clear() { q.buf = q.buf[:0] }\nfunc (q *STRUCTNAME) Len() int { return len(q.buf) }\nfunc (q *STRUCTNAME) Push(v DATATYPE1) { q.buf = append(q.buf, v); q.siftdown(0, len(q.buf)-1) }\nfunc (q *STRUCTNAME) Head() DATATYPE1 { return q.buf[0] }\nfunc (q *STRUCTNAME) Pop() DATATYPE1 {\n\tv1 := q.buf[0]; l := len(q.buf)\n\tif l == 1 { q.buf = q.buf[:0] } else { l--; q.buf[0] = q.buf[l]; q.buf = q.buf[:l]; q.siftup(0) }; return v1\n}\nfunc (q *STRUCTNAME) Heapify(pri []DATATYPE1) {\n\tq.buf = append(q.buf, pri...); n := len(q.buf); for i := n/2 - 1; i >= 0; i-- { q.siftup(i) }\n}\nfunc (q *STRUCTNAME) siftdown(startpos, pos int) {\n\tnewitem := q.buf[pos]\n\tfor pos > startpos {\n\t\tppos := (pos - 1) >> 1; p := q.buf[ppos]; if !q.less(newitem, p) { break }; q.buf[pos], pos = p, ppos\n\t}\n\tq.buf[pos] = newitem\n}\nfunc (q *STRUCTNAME) siftup(pos int) {\n\tendpos, startpos, newitem, chpos := len(q.buf), pos, q.buf[pos], 2*pos+1\n\tfor chpos < endpos {\n\t\trtpos := chpos + 1; if rtpos < endpos && !q.less(q.buf[chpos], q.buf[rtpos]) { chpos = rtpos }\n\t\tq.buf[pos], pos = q.buf[chpos], chpos; chpos = 2*pos + 1\n\t}\n\tq.buf[pos] = newitem; q.siftdown(startpos, pos)\n}",
    "segtree": "type STRUCTNAME struct { n, size, log int; op func(DATATYPE1, DATATYPE1) DATATYPE1; e DATATYPE1; d []DATATYPE1 }\nfunc NewSTRUCTNAME(n int, op func(DATATYPE1, DATATYPE1) DATATYPE1, e DATATYPE1) *STRUCTNAME {\n\tv := make([]DATATYPE1, n); for i := 0; i < n; i++ { v[i] = e }; return NewSTRUCTNAMEVec(v, op, e)\n}\nfunc NewSTRUCTNAMEVec(v []DATATYPE1, op func(DATATYPE1, DATATYPE1) DATATYPE1, e DATATYPE1) *STRUCTNAME {\n\tn, sz, log := len(v), 1, 0; for sz < n { sz <<= 1; log += 1 }; d := make([]DATATYPE1, 2*sz); d[0] = e\n\tfor i := 0; i < n; i++ { d[sz+i] = v[i] }; st := &STRUCTNAME{n, sz, log, op, e, d}\n\tfor i := sz - 1; i >= 1; i-- { st.update(i) }; return st\n}\nfunc (q *STRUCTNAME) Set(p int, v DATATYPE1) {\n\tp += q.size; q.d[p] = v; for i := 1; i <= q.log; i++ { q.update(p >> uint(i)) }\n}\nfunc (q *STRUCTNAME) Get(p int) DATATYPE1 { return q.d[p+q.size] }\nfunc (q *STRUCTNAME) Prod(l int, r int) DATATYPE1 {\n\tif r < l { return q.e }; r += 1; sml, smr := q.e, q.e; l += q.size; r += q.size\n\tfor l < r {\n\t\tif l&1 != 0 { sml = q.op(sml, q.d[l]); l++ }; if r&1 != 0 { r--; smr = q.op(q.d[r], smr) }; l >>= 1; r >>= 1\n\t}\n\treturn q.op(sml, smr)\n}\nfunc (q *STRUCTNAME) Allprod() DATATYPE1 { return q.d[1] }\nfunc (q *STRUCTNAME) MaxRight(l int, f func(DATATYPE1) bool) int {\n\tif l == q.n { return q.n - 1 }; l += q.size; sm := q.e\n\tfor {\n\t\tfor l%2 == 0 { l >>= 1 }\n\t\tif !f(q.op(sm, q.d[l])) {\n\t\t\tfor l < q.size { l *= 2; if f(q.op(sm, q.d[l])) { sm = q.op(sm, q.d[l]); l++ } }; return l - q.size - 1\n\t\t}\n\t\tsm = q.op(sm, q.d[l]); l++; if l&-l == l { break }\n\t}\n\treturn q.n - 1\n}\nfunc (q *STRUCTNAME) MinLeft(r int, f func(DATATYPE1) bool) int {\n\tif r < 0 { return 0 }; r += q.size; sm := q.e; r++ \n\tfor {\n\t\tr--; for r > 1 && r%2 == 1 { r >>= 1 }\n\t\tif !f(q.op(q.d[r], sm)) {\n\t\t\tfor r < q.size { r = 2*r + 1; if f(q.op(q.d[r], sm)) { sm = q.op(q.d[r], sm); r-- } }; return r + 1 - q.size\n\t\t}\n\t\tsm = q.op(q.d[r], sm); if r&-r == r { break }\n\t}\n\treturn 0\n}\nfunc (q *STRUCTNAME) update(k int) { q.d[k] = q.op(q.d[2*k], q.d[2*k+1]) }",
    "lazysegtree": "type STRUCTNAME struct {\n\tn, size, log int; op func(DATATYPE1, DATATYPE1) DATATYPE1; mapping func(DATATYPE2, DATATYPE1) DATATYPE1\n\tcomposition func(DATATYPE2, DATATYPE2) DATATYPE2; e DATATYPE1; id DATATYPE2; d []DATATYPE1; lz []DATATYPE2\n}\nfunc NewSTRUCTNAME(n int, op func(DATATYPE1, DATATYPE1) DATATYPE1, mapping func(DATATYPE2, DATATYPE1) DATATYPE1, composition func(DATATYPE2, DATATYPE2) DATATYPE2, e DATATYPE1, id DATATYPE2) *STRUCTNAME {\n\tv := make([]DATATYPE1, n); for i := 0; i < n; i++ { v[i] = e }\n\treturn NewSTRUCTNAMEVec(v, op, mapping, composition, e, id)\n}\nfunc NewSTRUCTNAMEVec(v []DATATYPE1, op func(DATATYPE1, DATATYPE1) DATATYPE1, mapping func(DATATYPE2, DATATYPE1) DATATYPE1, composition func(DATATYPE2, DATATYPE2) DATATYPE2, e DATATYPE1, id DATATYPE2) *STRUCTNAME {\n\tn, sz, log := len(v), 1, 0; for sz < n { sz <<= 1; log += 1 }; d := make([]DATATYPE1, 2*sz)\n\tlz := make([]DATATYPE2, sz); for i := 0; i < 2*sz; i++ { d[i] = e }; for i := 0; i < sz; i++ { lz[i] = id }; d[0] = e\n\tfor i := 0; i < n; i++ { d[sz+i] = v[i]; lz[i] = id }\n\tst := &STRUCTNAME{n, sz, log, op, mapping, composition, e, id, d, lz}\n\tfor i := sz - 1; i >= 1; i-- { st.update(i) }; return st\n}\nfunc (q *STRUCTNAME) Set(p int, v DATATYPE1) {\n\tp += q.size; for i := q.log; i >= 1; i-- { q.push(p >> uint(i)) }; q.d[p] = v\n\tfor i := 1; i <= q.log; i++ { q.update(p >> uint(i)) }\n}\nfunc (q *STRUCTNAME) Get(p int) DATATYPE1 {\n\tp += q.size; for i := q.log; i >= 1; i-- { q.push(p >> uint(i)) }; return q.d[p]\n}\nfunc (q *STRUCTNAME) Prod(l int, r int) DATATYPE1 {\n\tif r < l { return q.e }; l += q.size; r += q.size; r += 1 \n\tfor i := q.log; i >= 1; i-- {\n\t\tif ((l >> uint(i)) << uint(i)) != l { q.push(l >> uint(i)) }\n\t\tif ((r >> uint(i)) << uint(i)) != r { q.push((r - 1) >> uint(i)) }\n\t}\n\tsml, smr := q.e, q.e\n\tfor l < r {\n\t\tif l&1 != 0 { sml = q.op(sml, q.d[l]); l++ }; if r&1 != 0 { r--; smr = q.op(q.d[r], smr) }; l >>= 1; r >>= 1\n\t}\n\treturn q.op(sml, smr)\n}\nfunc (q *STRUCTNAME) Allprod() DATATYPE1 { return q.d[1] }\nfunc (q *STRUCTNAME) Apply(p int, f DATATYPE2) {\n\tp += q.size; for i := q.log; i >= 1; i-- { q.push(p >> uint(i)) }; q.d[p] = q.mapping(f, q.d[p])\n\tfor i := 1; i <= q.log; i++ { q.update(p >> uint(i)) }\n}\nfunc (q *STRUCTNAME) ApplyRange(l int, r int, f DATATYPE2) {\n\tif r < l { return }; r += 1; l += q.size; r += q.size\n\tfor i := q.log; i >= 1; i-- {\n\t\tif ((l >> uint(i)) << uint(i)) != l { q.push(l >> uint(i)) }\n\t\tif ((r >> uint(i)) << uint(i)) != r { q.push((r - 1) >> uint(i)) }\n\t}\n\tl2, r2 := l, r\n\tfor l < r { if l&1 != 0 { q.allApply(l, f); l += 1 }; if r&1 != 0 { r -= 1; q.allApply(r, f) }; l >>= 1; r >>= 1 }\n\tl, r = l2, r2\n\tfor i := 1; i <= q.log; i++ {\n\t\tif ((l >> uint(i)) << uint(i)) != l { q.update(l >> uint(i)) }\n\t\tif ((r >> uint(i)) << uint(i)) != r { q.update((r - 1) >> uint(i)) }\n\t}\n}\nfunc (q *STRUCTNAME) MaxRight(l int, f func(DATATYPE1) bool) int {\n\tif l == q.n { return q.n - 1 }; l += q.size; for i := q.log; i >= 1; i-- { q.push(l >> uint(i)) }; sm := q.e\n\tfor {\n\t\tfor l%2 == 0 { l >>= 1 }\n\t\tif !f(q.op(sm, q.d[l])) {\n\t\t\tfor l < q.size { q.push(l); l *= 2; if f(q.op(sm, q.d[l])) { sm = q.op(sm, q.d[l]); l++ } }\n\t\t\treturn l - q.size - 1\n\t\t}\n\t\tsm = q.op(sm, q.d[l]); l++; if l&-l == l { break }\n\t}\n\treturn q.n - 1\n}\nfunc (q *STRUCTNAME) MinLeft(r int, f func(DATATYPE1) bool) int {\n\tif r < 0 { return 0 }; r += q.size; r++; for i := q.log; i >= 1; i-- { q.push((r - 1) >> uint(i)) }; sm := q.e \n\tfor {\n\t\tr--; for r > 1 && r%2 == 1 { r >>= 1 }\n\t\tif !f(q.op(q.d[r], sm)) {\n\t\t\tfor r < q.size { q.push(r); r = 2*r + 1; if f(q.op(q.d[r], sm)) { sm = q.op(q.d[r], sm); r-- } }\n\t\t\treturn r + 1 - q.size\n\t\t}\n\t\tsm = q.op(q.d[r], sm); if r&-r == r { break }\n\t}\n\treturn 0\n}\nfunc (q *STRUCTNAME) update(k int) { q.d[k] = q.op(q.d[2*k], q.d[2*k+1]) }\nfunc (q *STRUCTNAME) allApply(k int, f DATATYPE2) {\n\tq.d[k] = q.mapping(f, q.d[k]); if k < q.size { q.lz[k] = q.composition(f, q.lz[k]) }\n}\nfunc (q *STRUCTNAME) push(k int) { q.allApply(2*k, q.lz[k]); q.allApply(2*k+1, q.lz[k]); q.lz[k] = q.id }",
    "rbtreeset": "type STRUCTNAMEnode struct { left, right, up int32; red bool; key DATATYPE1 }\ntype STRUCTNAME struct {\n\tlessthan func(a, b DATATYPE1) bool; tree []STRUCTNAMEnode; root int32; recycler []int32; sz int; minidx int32\n\tmaxidx int32\n}\ntype STRUCTNAMEIterator interface { Next() (ok bool); Prev() (ok bool); Key() DATATYPE1 }\ntype STRUCTNAMEiter struct { cur int32; key DATATYPE1; rbtree *STRUCTNAME }\nfunc (i *STRUCTNAMEiter) Key() DATATYPE1 { return i.key }\nfunc (i *STRUCTNAMEiter) Next() bool {\n\trbtree := i.rbtree; v := rbtree.nextidx(i.cur); if v == 0 { return false }; i.cur, i.key = v, rbtree.tree[v].key\n\treturn true\n}\nfunc (i *STRUCTNAMEiter) Prev() bool {\n\trbtree := i.rbtree; v := rbtree.previdx(i.cur); if v == 0 { return false }; i.cur, i.key = v, rbtree.tree[v].key\n\treturn true\n}\nfunc NewSTRUCTNAME(lessthan func(a, b DATATYPE1) bool) *STRUCTNAME {\n\tq := &STRUCTNAME{lessthan, make([]STRUCTNAMEnode, 2), int32(0), make([]int32, 0), 0, 0, 0}\n\tq.tree[0].left, q.tree[0].right, q.tree[0].up, q.tree[0].red = 0, 0, 0, false; q.recycler = append(q.recycler, 1)\n\treturn q\n}\nfunc (q *STRUCTNAME) Add(k DATATYPE1) {\n\tif q.sz == 0 {\n\t\tz := q.getNewNodenum(); tree := q.tree; q.minidx, q.maxidx, q.sz, q.root = z, z, q.sz+1, z\n\t\ttree[z].key, tree[z].up, tree[z].left, tree[z].right, tree[z].red = k, 0, 0, 0, false; return\n\t}\n\ty, cmp := q.findInsertionPoint(k); if cmp == 0 { return }; z := q.getNewNodenum(); q.sz += 1; tree := q.tree\n\ttree[z].key, tree[z].up, tree[z].left, tree[z].right, tree[z].red = k, y, 0, 0, true\n\tif cmp < 0 { tree[y].left = z } else { tree[y].right = z }\n\tif q.sz == 0 || q.lessthan(k, tree[q.minidx].key) { q.minidx = z }\n\tif q.sz == 0 || q.lessthan(tree[q.maxidx].key, k) { q.maxidx = z }; var p, g, u int32\n\tfor p = tree[z].up; tree[p].red; p = tree[z].up { \n\t\tg = tree[p].up ; if g == 0 { break } \n\t\tif p == tree[g].left {\n\t\t\tu = tree[g].right\n\t\t\tif tree[u].red { tree[p].red, tree[u].red, tree[g].red, z = false, false, true, g; continue }\n\t\t\tif z == tree[p].right { z = p; q.rotleft(z); p = tree[z].up }; q.rotright(g)\n\t\t\ttree[g].red, tree[p].red = true, false\n\t\t} else { \n\t\t\tu = tree[g].left\n\t\t\tif tree[u].red { tree[p].red, tree[u].red, tree[g].red, z = false, false, true, g; continue }\n\t\t\tif z == tree[p].left { z = p; q.rotright(z); p = tree[z].up }; q.rotleft(g)\n\t\t\ttree[g].red, tree[p].red = true, false\n\t\t}\n\t}\n\ttree[q.root].red = false\n}\nfunc (q *STRUCTNAME) Delete(k DATATYPE1) bool {\n\tif q.sz == 0 { return false }; z, cmp := q.findInsertionPoint(k); if cmp != 0 { return false }; q.sz--\n\tq.recycler = append(q.recycler, z)\n\tif q.sz > 0 && !q.lessthan(q.tree[q.minidx].key, k) { q.minidx = q.nextidx(q.minidx) }\n\tif q.sz > 0 && !q.lessthan(k, q.tree[q.maxidx].key) { q.maxidx = q.previdx(q.maxidx) }\n\tif q.sz == 0 { q.root = 0; return true }; tree := q.tree; var x int32; y, y_orig_red := z, tree[z].red\n\tif tree[z].left == 0 {\n\t\tx = tree[z].right; q.rbTransplant(z, x)\n\t} else if tree[z].right == 0 {\n\t\tx = tree[z].left; q.rbTransplant(z, x)\n\t} else {\n\t\ty = q.findminidx(tree[z].right); y_orig_red = tree[y].red; x = tree[y].right\n\t\tif tree[y].up == z {\n\t\t\ttree[x].up = y \n\t\t} else {\n\t\t\tq.rbTransplant(y, x); tree[y].right = tree[z].right; tree[tree[y].right].up = y\n\t\t}\n\t\tq.rbTransplant(z, y); tree[y].left = tree[z].left; tree[tree[y].left].up = y; tree[y].red = tree[z].red\n\t}\n\tif !y_orig_red {\n\t\tfor q.root != x && !tree[x].red {\n\t\t\tp := tree[x].up\n\t\t\tif tree[p].left == x {\n\t\t\t\ts := tree[p].right \n\t\t\t\tif tree[s].red { tree[s].red = false; tree[p].red = true; q.rotleft(p); s = tree[p].right }\n\t\t\t\tc := tree[s].left; d := tree[s].right\n\t\t\t\tif !tree[c].red && !tree[d].red {\n\t\t\t\t\ttree[s].red = true; x = p\n\t\t\t\t} else {\n\t\t\t\t\tif !tree[d].red { tree[c].red = false; tree[s].red = true; q.rotright(s); s = tree[p].right }\n\t\t\t\t\ttree[s].red = tree[p].red; tree[p].red = false; tree[tree[s].right].red = false; q.rotleft(p)\n\t\t\t\t\tx = q.root\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts := tree[p].left \n\t\t\t\tif tree[s].red { tree[s].red = false; tree[p].red = true; q.rotright(p); s = tree[p].left }\n\t\t\t\tc := tree[s].right; d := tree[s].left\n\t\t\t\tif !tree[c].red && !tree[d].red {\n\t\t\t\t\ttree[s].red = true; x = p\n\t\t\t\t} else {\n\t\t\t\t\tif !tree[d].red { tree[c].red = false; tree[s].red = true; q.rotleft(s); s = tree[p].left }\n\t\t\t\t\ttree[s].red = tree[p].red; tree[p].red = false; tree[tree[s].left].red = false; q.rotright(p)\n\t\t\t\t\tx = q.root\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttree[x].red = false\n\t}\n\treturn true\n}\nfunc (q *STRUCTNAME) Clear() {\n\tq.tree, q.root, q.recycler, q.sz = q.tree[:2], 0, q.recycler[:0], 0; q.recycler = append(q.recycler, int32(1))\n}\nfunc (q *STRUCTNAME) IsEmpty() bool { return q.sz == 0 }\nfunc (q *STRUCTNAME) Contains(k DATATYPE1) bool { _, cmp := q.findInsertionPoint(k); return cmp == 0 }\nfunc (q *STRUCTNAME) Count(k DATATYPE1) int { _, cmp := q.findInsertionPoint(k); if cmp == 0 { return 1 }; return 0 }\nfunc (q *STRUCTNAME) Len() int { return q.sz }\nfunc (q *STRUCTNAME) MinKey() (k DATATYPE1) {\n\tif q.sz == 0 { panic(\"Called MinKey on an empty STRUCTNAME\") }; return q.tree[q.minidx].key\n}\nfunc (q *STRUCTNAME) MaxKey() (k DATATYPE1) {\n\tif q.sz == 0 { panic(\"Called MaxKey on an empty STRUCTNAME\") }; return q.tree[q.maxidx].key\n}\nfunc (q *STRUCTNAME) findLtIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || !q.lessthan(q.tree[q.minidx].key, k) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos != 1 { idx = q.previdx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findLeIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || q.lessthan(k, q.tree[q.minidx].key) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos == -1 { idx = q.previdx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findGtIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || !q.lessthan(k, q.tree[q.maxidx].key) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos != -1 { idx = q.nextidx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findGeIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || q.lessthan(q.tree[q.maxidx].key, k) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos == 1 { idx = q.nextidx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) FindLt(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findLtIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLe(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findLeIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGt(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findGtIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGe(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findGeIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLtIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findLtIdx(k); if ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q} }\n\treturn ans, ok\n}\nfunc (q *STRUCTNAME) FindLeIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findLeIdx(k); if ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q} }\n\treturn ans, ok\n}\nfunc (q *STRUCTNAME) FindGtIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findGtIdx(k); if ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q} }\n\treturn ans, ok\n}\nfunc (q *STRUCTNAME) FindGeIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findGeIdx(k); if ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q} }\n\treturn ans, ok\n}\nfunc (q *STRUCTNAME) FindIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx, pos := q.findInsertionPoint(k); if pos != 0 { return nil, false }\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q}, true\n}\nfunc (q *STRUCTNAME) MinIter() (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx := q.findminidx(q.root)\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q}, true\n}\nfunc (q *STRUCTNAME) MaxIter() (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx := q.findmaxidx(q.root)\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q}, true\n}\nfunc (q *STRUCTNAME) rbTransplant(u, v int32) {\n\ttree := q.tree\n\tif tree[u].up == 0 {\n\t\tq.root = v\n\t} else {\n\t\tp := tree[u].up; if u == tree[p].left { tree[p].left = v } else { tree[p].right = v }\n\t}\n\ttree[v].up = tree[u].up\n}\nfunc (q *STRUCTNAME) findInsertionPoint(k DATATYPE1) (int32, int8) {\n\tn, lt, tree := q.root, q.lessthan, q.tree\n\tfor {\n\t\tnkey := tree[n].key\n\t\tif lt(nkey, k) {\n\t\t\tr := tree[n].right; if r == 0 { return n, 1 }; n = r\n\t\t} else if lt(k, nkey) {\n\t\t\tl := tree[n].left; if l == 0 { return n, -1 }; n = l\n\t\t} else {\n\t\t\treturn n, 0\n\t\t}\n\t}\n}\nfunc (q *STRUCTNAME) findmaxidx(n1 int32) int32 {\n\ttree := q.tree; for { xx := tree[n1].right; if xx == 0 { break }; n1 = xx }; return n1\n}\nfunc (q *STRUCTNAME) findminidx(n1 int32) int32 {\n\ttree := q.tree; for { xx := tree[n1].left; if xx == 0 { break }; n1 = xx }; return n1\n}\nfunc (q *STRUCTNAME) nextidx(cur int32) int32 {\n\tlast := int32(-2); tree := q.tree; rr := tree[cur].right; if rr > 0 { return q.findminidx(rr) }\n\tfor { last, cur = cur, tree[cur].up; if cur == 0 || tree[cur].left == last { break } }; return cur\n}\nfunc (q *STRUCTNAME) previdx(cur int32) int32 {\n\tlast := int32(0); tree := q.tree; ll := tree[cur].left; if ll > 0 { return q.findmaxidx(ll) }\n\tfor { last, cur = cur, tree[cur].up; if cur == 0 || tree[cur].right == last { break } }; return cur\n}\nfunc (q *STRUCTNAME) rotleft(x int32) {\n\ttree := q.tree; y := tree[x].right; p := tree[x].up; tree[x].right = tree[y].left\n\tif tree[y].left != 0 { tree[tree[y].left].up = x }; tree[y].up = p\n\tif p == 0 {\n\t\tq.root = y\n\t} else if x == tree[p].left {\n\t\ttree[p].left = y\n\t} else {\n\t\ttree[p].right = y\n\t}\n\ttree[y].left = x; tree[x].up = y\n}\nfunc (q *STRUCTNAME) rotright(x int32) {\n\ttree := q.tree; y := tree[x].left; p := tree[x].up; tree[x].left = tree[y].right\n\tif tree[y].right != 0 { tree[tree[y].right].up = x }; tree[y].up = p\n\tif p == 0 {\n\t\tq.root = y\n\t} else if x == tree[p].right {\n\t\ttree[p].right = y\n\t} else {\n\t\ttree[p].left = y\n\t}\n\ttree[y].right = x; tree[x].up = y\n}\nfunc (q *STRUCTNAME) getNewNodenum() int32 {\n\tl := len(q.recycler); newnode := q.recycler[l-1]; q.recycler = q.recycler[:l-1]\n\tif l == 1 { q.tree = append(q.tree, STRUCTNAMEnode{}); q.recycler = append(q.recycler, int32(len(q.tree)-1)) }\n\treturn newnode\n}",
    "rbtreemultiset": "type STRUCTNAMEnode struct { left, right, up int32; red bool; key DATATYPE1; count int }\ntype STRUCTNAME struct {\n\tlessthan func(a, b DATATYPE1) bool; tree []STRUCTNAMEnode; root int32; recycler []int32; sz int; minidx int32\n\tmaxidx int32\n}\ntype STRUCTNAMEIterator interface { Next() (ok bool); Prev() (ok bool); Key() DATATYPE1; Count() int }\ntype STRUCTNAMEiter struct { cur int32; key DATATYPE1; count int; rbtree *STRUCTNAME }\nfunc (i *STRUCTNAMEiter) Key() DATATYPE1 { return i.key }\nfunc (i *STRUCTNAMEiter) Count() int { return i.count }\nfunc (i *STRUCTNAMEiter) Next() bool {\n\trbtree := i.rbtree; v := rbtree.nextidx(i.cur); if v == 0 { return false }\n\ti.cur, i.key, i.count = v, rbtree.tree[v].key, rbtree.tree[v].count; return true\n}\nfunc (i *STRUCTNAMEiter) Prev() bool {\n\trbtree := i.rbtree; v := rbtree.previdx(i.cur); if v == 0 { return false }\n\ti.cur, i.key, i.count = v, rbtree.tree[v].key, rbtree.tree[v].count; return true\n}\nfunc NewSTRUCTNAME(lessthan func(a, b DATATYPE1) bool) *STRUCTNAME {\n\tq := &STRUCTNAME{lessthan, make([]STRUCTNAMEnode, 2), int32(0), make([]int32, 0), 0, 0, 0}\n\tq.tree[0].left, q.tree[0].right, q.tree[0].up, q.tree[0].red = 0, 0, 0, false; q.recycler = append(q.recycler, 1)\n\treturn q\n}\nfunc (q *STRUCTNAME) Add(k DATATYPE1) {\n\tif q.sz == 0 {\n\t\tz := q.getNewNodenum(); tree := q.tree; q.minidx, q.maxidx, q.sz, q.root = z, z, q.sz+1, z\n\t\ttree[z].key, tree[z].count, tree[z].up, tree[z].left, tree[z].right, tree[z].red = k, 1, 0, 0, 0, false; return\n\t}\n\ty, cmp := q.findInsertionPoint(k); if cmp == 0 { q.tree[y].count++; q.sz += 1; return }; z := q.getNewNodenum()\n\tq.sz += 1; tree := q.tree\n\ttree[z].key, tree[z].count, tree[z].up, tree[z].left, tree[z].right, tree[z].red = k, 1, y, 0, 0, true\n\tif cmp < 0 { tree[y].left = z } else { tree[y].right = z }\n\tif q.sz == 0 || q.lessthan(k, tree[q.minidx].key) { q.minidx = z }\n\tif q.sz == 0 || q.lessthan(tree[q.maxidx].key, k) { q.maxidx = z }; var p, g, u int32\n\tfor p = tree[z].up; tree[p].red; p = tree[z].up { \n\t\tg = tree[p].up ; if g == 0 { break } \n\t\tif p == tree[g].left {\n\t\t\tu = tree[g].right\n\t\t\tif tree[u].red { tree[p].red, tree[u].red, tree[g].red, z = false, false, true, g; continue }\n\t\t\tif z == tree[p].right { z = p; q.rotleft(z); p = tree[z].up }; q.rotright(g)\n\t\t\ttree[g].red, tree[p].red = true, false\n\t\t} else { \n\t\t\tu = tree[g].left\n\t\t\tif tree[u].red { tree[p].red, tree[u].red, tree[g].red, z = false, false, true, g; continue }\n\t\t\tif z == tree[p].left { z = p; q.rotright(z); p = tree[z].up }; q.rotleft(g)\n\t\t\ttree[g].red, tree[p].red = true, false\n\t\t}\n\t}\n\ttree[q.root].red = false\n}\nfunc (q *STRUCTNAME) Delete(k DATATYPE1) bool {\n\tif q.sz == 0 { return false }; z, cmp := q.findInsertionPoint(k)\n\tif cmp != 0 { return false } else if q.tree[z].count > 1 { q.tree[z].count--; q.sz--; return true }; q.sz--\n\tq.recycler = append(q.recycler, z)\n\tif q.sz > 0 && !q.lessthan(q.tree[q.minidx].key, k) { q.minidx = q.nextidx(q.minidx) }\n\tif q.sz > 0 && !q.lessthan(k, q.tree[q.maxidx].key) { q.maxidx = q.previdx(q.maxidx) }\n\tif q.sz == 0 { q.root = 0; return true }; tree := q.tree; var x int32; y, y_orig_red := z, tree[z].red\n\tif tree[z].left == 0 {\n\t\tx = tree[z].right; q.rbTransplant(z, x)\n\t} else if tree[z].right == 0 {\n\t\tx = tree[z].left; q.rbTransplant(z, x)\n\t} else {\n\t\ty = q.findminidx(tree[z].right); y_orig_red = tree[y].red; x = tree[y].right\n\t\tif tree[y].up == z {\n\t\t\ttree[x].up = y \n\t\t} else {\n\t\t\tq.rbTransplant(y, x); tree[y].right = tree[z].right; tree[tree[y].right].up = y\n\t\t}\n\t\tq.rbTransplant(z, y); tree[y].left = tree[z].left; tree[tree[y].left].up = y; tree[y].red = tree[z].red\n\t}\n\tif !y_orig_red {\n\t\tfor q.root != x && !tree[x].red {\n\t\t\tp := tree[x].up\n\t\t\tif tree[p].left == x {\n\t\t\t\ts := tree[p].right \n\t\t\t\tif tree[s].red { tree[s].red = false; tree[p].red = true; q.rotleft(p); s = tree[p].right }\n\t\t\t\tc := tree[s].left; d := tree[s].right\n\t\t\t\tif !tree[c].red && !tree[d].red {\n\t\t\t\t\ttree[s].red = true; x = p\n\t\t\t\t} else {\n\t\t\t\t\tif !tree[d].red { tree[c].red = false; tree[s].red = true; q.rotright(s); s = tree[p].right }\n\t\t\t\t\ttree[s].red = tree[p].red; tree[p].red = false; tree[tree[s].right].red = false; q.rotleft(p)\n\t\t\t\t\tx = q.root\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts := tree[p].left \n\t\t\t\tif tree[s].red { tree[s].red = false; tree[p].red = true; q.rotright(p); s = tree[p].left }\n\t\t\t\tc := tree[s].right; d := tree[s].left\n\t\t\t\tif !tree[c].red && !tree[d].red {\n\t\t\t\t\ttree[s].red = true; x = p\n\t\t\t\t} else {\n\t\t\t\t\tif !tree[d].red { tree[c].red = false; tree[s].red = true; q.rotleft(s); s = tree[p].left }\n\t\t\t\t\ttree[s].red = tree[p].red; tree[p].red = false; tree[tree[s].left].red = false; q.rotright(p)\n\t\t\t\t\tx = q.root\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttree[x].red = false\n\t}\n\treturn true\n}\nfunc (q *STRUCTNAME) Clear() {\n\tq.tree, q.root, q.recycler, q.sz = q.tree[:2], 0, q.recycler[:0], 0; q.recycler = append(q.recycler, int32(1))\n}\nfunc (q *STRUCTNAME) IsEmpty() bool { return q.sz == 0 }\nfunc (q *STRUCTNAME) Contains(k DATATYPE1) bool { _, cmp := q.findInsertionPoint(k); return cmp == 0 }\nfunc (q *STRUCTNAME) Count(k DATATYPE1) int {\n\tz, cmp := q.findInsertionPoint(k); if cmp != 0 { return 0 }; return q.tree[z].count\n}\nfunc (q *STRUCTNAME) Len() int { return q.sz }\nfunc (q *STRUCTNAME) MinKey() (k DATATYPE1) {\n\tif q.sz == 0 { panic(\"Called MinKey on an empty STRUCTNAME\") }; return q.tree[q.minidx].key\n}\nfunc (q *STRUCTNAME) MaxKey() (k DATATYPE1) {\n\tif q.sz == 0 { panic(\"Called MaxKey on an empty STRUCTNAME\") }; return q.tree[q.maxidx].key\n}\nfunc (q *STRUCTNAME) findLtIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || !q.lessthan(q.tree[q.minidx].key, k) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos != 1 { idx = q.previdx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findLeIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || q.lessthan(k, q.tree[q.minidx].key) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos == -1 { idx = q.previdx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findGtIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || !q.lessthan(k, q.tree[q.maxidx].key) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos != -1 { idx = q.nextidx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findGeIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || q.lessthan(q.tree[q.maxidx].key, k) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos == 1 { idx = q.nextidx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) FindLt(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findLtIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLe(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findLeIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGt(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findGtIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGe(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findGeIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLtIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findLtIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLeIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findLeIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGtIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findGtIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGeIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findGeIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx, pos := q.findInsertionPoint(k); if pos != 0 { return nil, false }\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q}, true\n}\nfunc (q *STRUCTNAME) MinIter() (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx := q.findminidx(q.root)\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q}, true\n}\nfunc (q *STRUCTNAME) MaxIter() (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx := q.findmaxidx(q.root)\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].count, q}, true\n}\nfunc (q *STRUCTNAME) rbTransplant(u, v int32) {\n\ttree := q.tree\n\tif tree[u].up == 0 {\n\t\tq.root = v\n\t} else {\n\t\tp := tree[u].up; if u == tree[p].left { tree[p].left = v } else { tree[p].right = v }\n\t}\n\ttree[v].up = tree[u].up\n}\nfunc (q *STRUCTNAME) findInsertionPoint(k DATATYPE1) (int32, int8) {\n\tn, lt, tree := q.root, q.lessthan, q.tree\n\tfor {\n\t\tnkey := tree[n].key\n\t\tif lt(nkey, k) {\n\t\t\tr := tree[n].right; if r == 0 { return n, 1 }; n = r\n\t\t} else if lt(k, nkey) {\n\t\t\tl := tree[n].left; if l == 0 { return n, -1 }; n = l\n\t\t} else {\n\t\t\treturn n, 0\n\t\t}\n\t}\n}\nfunc (q *STRUCTNAME) findmaxidx(n1 int32) int32 {\n\ttree := q.tree; for { xx := tree[n1].right; if xx == 0 { break }; n1 = xx }; return n1\n}\nfunc (q *STRUCTNAME) findminidx(n1 int32) int32 {\n\ttree := q.tree; for { xx := tree[n1].left; if xx == 0 { break }; n1 = xx }; return n1\n}\nfunc (q *STRUCTNAME) nextidx(cur int32) int32 {\n\tlast := int32(-2); tree := q.tree; rr := tree[cur].right; if rr > 0 { return q.findminidx(rr) }\n\tfor { last, cur = cur, tree[cur].up; if cur == 0 || tree[cur].left == last { break } }; return cur\n}\nfunc (q *STRUCTNAME) previdx(cur int32) int32 {\n\tlast := int32(0); tree := q.tree; ll := tree[cur].left; if ll > 0 { return q.findmaxidx(ll) }\n\tfor { last, cur = cur, tree[cur].up; if cur == 0 || tree[cur].right == last { break } }; return cur\n}\nfunc (q *STRUCTNAME) rotleft(x int32) {\n\ttree := q.tree; y := tree[x].right; p := tree[x].up; tree[x].right = tree[y].left\n\tif tree[y].left != 0 { tree[tree[y].left].up = x }; tree[y].up = p\n\tif p == 0 {\n\t\tq.root = y\n\t} else if x == tree[p].left {\n\t\ttree[p].left = y\n\t} else {\n\t\ttree[p].right = y\n\t}\n\ttree[y].left = x; tree[x].up = y\n}\nfunc (q *STRUCTNAME) rotright(x int32) {\n\ttree := q.tree; y := tree[x].left; p := tree[x].up; tree[x].left = tree[y].right\n\tif tree[y].right != 0 { tree[tree[y].right].up = x }; tree[y].up = p\n\tif p == 0 {\n\t\tq.root = y\n\t} else if x == tree[p].right {\n\t\ttree[p].right = y\n\t} else {\n\t\ttree[p].left = y\n\t}\n\ttree[y].right = x; tree[x].up = y\n}\nfunc (q *STRUCTNAME) getNewNodenum() int32 {\n\tl := len(q.recycler); newnode := q.recycler[l-1]; q.recycler = q.recycler[:l-1]\n\tif l == 1 { q.tree = append(q.tree, STRUCTNAMEnode{}); q.recycler = append(q.recycler, int32(len(q.tree)-1)) }\n\treturn newnode\n}",
    "rbtreemap": "type STRUCTNAMEnode struct { left, right, up int32; red bool; key DATATYPE1; val DATATYPE2 }\ntype STRUCTNAME struct {\n\tlessthan func(a, b DATATYPE1) bool; tree []STRUCTNAMEnode; root int32; recycler []int32; sz int; minidx int32\n\tmaxidx int32\n}\ntype STRUCTNAMEIterator interface { Next() (ok bool); Prev() (ok bool); Key() DATATYPE1; Value() DATATYPE2 }\ntype STRUCTNAMEiter struct { cur int32; key DATATYPE1; value DATATYPE2; rbtree *STRUCTNAME }\nfunc (i *STRUCTNAMEiter) Key() DATATYPE1 { return i.key }\nfunc (i *STRUCTNAMEiter) Value() DATATYPE2 { return i.value }\nfunc (i *STRUCTNAMEiter) Next() bool {\n\trbtree := i.rbtree; v := rbtree.nextidx(i.cur); if v == 0 { return false }\n\ti.cur, i.key, i.value = v, rbtree.tree[v].key, rbtree.tree[v].val; return true\n}\nfunc (i *STRUCTNAMEiter) Prev() bool {\n\trbtree := i.rbtree; v := rbtree.previdx(i.cur); if v == 0 { return false }\n\ti.cur, i.key, i.value = v, rbtree.tree[v].key, rbtree.tree[v].val; return true\n}\nfunc NewSTRUCTNAME(lessthan func(a, b DATATYPE1) bool) *STRUCTNAME {\n\tq := &STRUCTNAME{lessthan, make([]STRUCTNAMEnode, 2), int32(0), make([]int32, 0), 0, 0, 0}\n\tq.tree[0].left, q.tree[0].right, q.tree[0].up, q.tree[0].red = 0, 0, 0, false; q.recycler = append(q.recycler, 1)\n\treturn q\n}\nfunc (q *STRUCTNAME) Add(k DATATYPE1, v DATATYPE2) {\n\tif q.sz == 0 {\n\t\tz := q.getNewNodenum(); tree := q.tree; q.minidx, q.maxidx, q.sz, q.root = z, z, q.sz+1, z\n\t\ttree[z].key, tree[z].val, tree[z].up, tree[z].left, tree[z].right, tree[z].red = k, v, 0, 0, 0, false; return\n\t}\n\ty, cmp := q.findInsertionPoint(k); if cmp == 0 { q.tree[y].val = v; return }; z := q.getNewNodenum(); q.sz += 1\n\ttree := q.tree; tree[z].key, tree[z].val, tree[z].up, tree[z].left, tree[z].right, tree[z].red = k, v, y, 0, 0, true\n\tif cmp < 0 { tree[y].left = z } else { tree[y].right = z }\n\tif q.sz == 0 || q.lessthan(k, tree[q.minidx].key) { q.minidx = z }\n\tif q.sz == 0 || q.lessthan(tree[q.maxidx].key, k) { q.maxidx = z }; var p, g, u int32\n\tfor p = tree[z].up; tree[p].red; p = tree[z].up { \n\t\tg = tree[p].up ; if g == 0 { break } \n\t\tif p == tree[g].left {\n\t\t\tu = tree[g].right\n\t\t\tif tree[u].red { tree[p].red, tree[u].red, tree[g].red, z = false, false, true, g; continue }\n\t\t\tif z == tree[p].right { z = p; q.rotleft(z); p = tree[z].up }; q.rotright(g)\n\t\t\ttree[g].red, tree[p].red = true, false\n\t\t} else { \n\t\t\tu = tree[g].left\n\t\t\tif tree[u].red { tree[p].red, tree[u].red, tree[g].red, z = false, false, true, g; continue }\n\t\t\tif z == tree[p].left { z = p; q.rotright(z); p = tree[z].up }; q.rotleft(g)\n\t\t\ttree[g].red, tree[p].red = true, false\n\t\t}\n\t}\n\ttree[q.root].red = false\n}\nfunc (q *STRUCTNAME) Delete(k DATATYPE1) bool {\n\tif q.sz == 0 { return false }; z, cmp := q.findInsertionPoint(k); if cmp != 0 { return false }; q.sz--\n\tq.recycler = append(q.recycler, z)\n\tif q.sz > 0 && !q.lessthan(q.tree[q.minidx].key, k) { q.minidx = q.nextidx(q.minidx) }\n\tif q.sz > 0 && !q.lessthan(k, q.tree[q.maxidx].key) { q.maxidx = q.previdx(q.maxidx) }\n\tif q.sz == 0 { q.root = 0; return true }; tree := q.tree; var x int32; y, y_orig_red := z, tree[z].red\n\tif tree[z].left == 0 {\n\t\tx = tree[z].right; q.rbTransplant(z, x)\n\t} else if tree[z].right == 0 {\n\t\tx = tree[z].left; q.rbTransplant(z, x)\n\t} else {\n\t\ty = q.findminidx(tree[z].right); y_orig_red = tree[y].red; x = tree[y].right\n\t\tif tree[y].up == z {\n\t\t\ttree[x].up = y \n\t\t} else {\n\t\t\tq.rbTransplant(y, x); tree[y].right = tree[z].right; tree[tree[y].right].up = y\n\t\t}\n\t\tq.rbTransplant(z, y); tree[y].left = tree[z].left; tree[tree[y].left].up = y; tree[y].red = tree[z].red\n\t}\n\tif !y_orig_red {\n\t\tfor q.root != x && !tree[x].red {\n\t\t\tp := tree[x].up\n\t\t\tif tree[p].left == x {\n\t\t\t\ts := tree[p].right \n\t\t\t\tif tree[s].red { tree[s].red = false; tree[p].red = true; q.rotleft(p); s = tree[p].right }\n\t\t\t\tc := tree[s].left; d := tree[s].right\n\t\t\t\tif !tree[c].red && !tree[d].red {\n\t\t\t\t\ttree[s].red = true; x = p\n\t\t\t\t} else {\n\t\t\t\t\tif !tree[d].red { tree[c].red = false; tree[s].red = true; q.rotright(s); s = tree[p].right }\n\t\t\t\t\ttree[s].red = tree[p].red; tree[p].red = false; tree[tree[s].right].red = false; q.rotleft(p)\n\t\t\t\t\tx = q.root\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts := tree[p].left \n\t\t\t\tif tree[s].red { tree[s].red = false; tree[p].red = true; q.rotright(p); s = tree[p].left }\n\t\t\t\tc := tree[s].right; d := tree[s].left\n\t\t\t\tif !tree[c].red && !tree[d].red {\n\t\t\t\t\ttree[s].red = true; x = p\n\t\t\t\t} else {\n\t\t\t\t\tif !tree[d].red { tree[c].red = false; tree[s].red = true; q.rotleft(s); s = tree[p].left }\n\t\t\t\t\ttree[s].red = tree[p].red; tree[p].red = false; tree[tree[s].left].red = false; q.rotright(p)\n\t\t\t\t\tx = q.root\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttree[x].red = false\n\t}\n\treturn true\n}\nfunc (q *STRUCTNAME) Clear() {\n\tq.tree, q.root, q.recycler, q.sz = q.tree[:2], 0, q.recycler[:0], 0; q.recycler = append(q.recycler, int32(1))\n}\nfunc (q *STRUCTNAME) IsEmpty() bool { return q.sz == 0 }\nfunc (q *STRUCTNAME) Contains(k DATATYPE1) bool { _, cmp := q.findInsertionPoint(k); return cmp == 0 }\nfunc (q *STRUCTNAME) Lookup(k DATATYPE1) (DATATYPE2, bool) {\n\tvar def DATATYPE2; z, cmp := q.findInsertionPoint(k); if cmp == 0 { return q.tree[z].val, true }; return def, false\n}\nfunc (q *STRUCTNAME) Len() int { return q.sz }\nfunc (q *STRUCTNAME) MinKey() (k DATATYPE1) {\n\tif q.sz == 0 { panic(\"Called MinKey on an empty STRUCTNAME\") }; return q.tree[q.minidx].key\n}\nfunc (q *STRUCTNAME) MaxKey() (k DATATYPE1) {\n\tif q.sz == 0 { panic(\"Called MaxKey on an empty STRUCTNAME\") }; return q.tree[q.maxidx].key\n}\nfunc (q *STRUCTNAME) findLtIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || !q.lessthan(q.tree[q.minidx].key, k) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos != 1 { idx = q.previdx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findLeIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || q.lessthan(k, q.tree[q.minidx].key) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos == -1 { idx = q.previdx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findGtIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || !q.lessthan(k, q.tree[q.maxidx].key) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos != -1 { idx = q.nextidx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) findGeIdx(k DATATYPE1) (int32, bool) {\n\tif q.sz == 0 || q.lessthan(q.tree[q.maxidx].key, k) { return 0, false }; idx, pos := q.findInsertionPoint(k)\n\tif pos == 1 { idx = q.nextidx(idx) }; return idx, true\n}\nfunc (q *STRUCTNAME) FindLt(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findLtIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLe(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findLeIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGt(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findGtIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGe(k DATATYPE1) (DATATYPE1, bool) {\n\tvar ans DATATYPE1; idx, ok := q.findGeIdx(k); if ok { ans = q.tree[idx].key }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLtIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findLtIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindLeIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findLeIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGtIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findGtIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindGeIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tvar ans *STRUCTNAMEiter; idx, ok := q.findGeIdx(k)\n\tif ok { ans = &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q} }; return ans, ok\n}\nfunc (q *STRUCTNAME) FindIter(k DATATYPE1) (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx, pos := q.findInsertionPoint(k); if pos != 0 { return nil, false }\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q}, true\n}\nfunc (q *STRUCTNAME) MinIter() (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx := q.findminidx(q.root)\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q}, true\n}\nfunc (q *STRUCTNAME) MaxIter() (STRUCTNAMEIterator, bool) {\n\tif q.sz == 0 { return nil, false }; idx := q.findmaxidx(q.root)\n\treturn &STRUCTNAMEiter{idx, q.tree[idx].key, q.tree[idx].val, q}, true\n}\nfunc (q *STRUCTNAME) rbTransplant(u, v int32) {\n\ttree := q.tree\n\tif tree[u].up == 0 {\n\t\tq.root = v\n\t} else {\n\t\tp := tree[u].up; if u == tree[p].left { tree[p].left = v } else { tree[p].right = v }\n\t}\n\ttree[v].up = tree[u].up\n}\nfunc (q *STRUCTNAME) findInsertionPoint(k DATATYPE1) (int32, int8) {\n\tn, lt, tree := q.root, q.lessthan, q.tree\n\tfor {\n\t\tnkey := tree[n].key\n\t\tif lt(nkey, k) {\n\t\t\tr := tree[n].right; if r == 0 { return n, 1 }; n = r\n\t\t} else if lt(k, nkey) {\n\t\t\tl := tree[n].left; if l == 0 { return n, -1 }; n = l\n\t\t} else {\n\t\t\treturn n, 0\n\t\t}\n\t}\n}\nfunc (q *STRUCTNAME) findmaxidx(n1 int32) int32 {\n\ttree := q.tree; for { xx := tree[n1].right; if xx == 0 { break }; n1 = xx }; return n1\n}\nfunc (q *STRUCTNAME) findminidx(n1 int32) int32 {\n\ttree := q.tree; for { xx := tree[n1].left; if xx == 0 { break }; n1 = xx }; return n1\n}\nfunc (q *STRUCTNAME) nextidx(cur int32) int32 {\n\tlast := int32(-2); tree := q.tree; rr := tree[cur].right; if rr > 0 { return q.findminidx(rr) }\n\tfor { last, cur = cur, tree[cur].up; if cur == 0 || tree[cur].left == last { break } }; return cur\n}\nfunc (q *STRUCTNAME) previdx(cur int32) int32 {\n\tlast := int32(0); tree := q.tree; ll := tree[cur].left; if ll > 0 { return q.findmaxidx(ll) }\n\tfor { last, cur = cur, tree[cur].up; if cur == 0 || tree[cur].right == last { break } }; return cur\n}\nfunc (q *STRUCTNAME) rotleft(x int32) {\n\ttree := q.tree; y := tree[x].right; p := tree[x].up; tree[x].right = tree[y].left\n\tif tree[y].left != 0 { tree[tree[y].left].up = x }; tree[y].up = p\n\tif p == 0 {\n\t\tq.root = y\n\t} else if x == tree[p].left {\n\t\ttree[p].left = y\n\t} else {\n\t\ttree[p].right = y\n\t}\n\ttree[y].left = x; tree[x].up = y\n}\nfunc (q *STRUCTNAME) rotright(x int32) {\n\ttree := q.tree; y := tree[x].left; p := tree[x].up; tree[x].left = tree[y].right\n\tif tree[y].right != 0 { tree[tree[y].right].up = x }; tree[y].up = p\n\tif p == 0 {\n\t\tq.root = y\n\t} else if x == tree[p].right {\n\t\ttree[p].right = y\n\t} else {\n\t\ttree[p].left = y\n\t}\n\ttree[y].right = x; tree[x].up = y\n}\nfunc (q *STRUCTNAME) getNewNodenum() int32 {\n\tl := len(q.recycler); newnode := q.recycler[l-1]; q.recycler = q.recycler[:l-1]\n\tif l == 1 { q.tree = append(q.tree, STRUCTNAMEnode{}); q.recycler = append(q.recycler, int32(len(q.tree)-1)) }\n\treturn newnode\n}",
    "convolver": "var docstr = \"(998244353,3) works\"\nfunc CONVOLVERpowmod(a,e,mod int) int { res, m := 1, a; for e > 0 { if e&1 != 0 { res = res * m % mod }; m = m * m % mod; e >>= 1 }; return res }\ntype CONVOLVER struct{ mod, primroot, rank2 int; root,iroot,rate2,irate2,rate3,irate3 []int }\nfunc NewCONVOLVER(mod, primroot int) *CONVOLVER {\n\trank2 := bits.TrailingZeros(uint(mod-1))\n\tif rank2 < 3 { panic(\"Hard wired to work for a significantly large power of 2 in the modulus\") }\n\troot := make([]int,rank2+1); iroot := make([]int,rank2+1); rate2 := make([]int,rank2-2+1)\n\tirate2 := make([]int,rank2-2+1); rate3 := make([]int,rank2-3+1); irate3 := make([]int,rank2-3+1)\n\troot[rank2] = CONVOLVERpowmod(primroot,(mod-1)>>rank2,mod); iroot[rank2] = CONVOLVERpowmod(root[rank2],mod-2,mod)\n\tfor i:=rank2-1;i>=0;i-- { root[i] = root[i+1]*root[i+1] % mod; iroot[i] = iroot[i+1]*iroot[i+1] % mod }\n\tprod,iprod := 1,1\n\tfor i:=0;i<=rank2-2;i++ {\n\t\trate2[i] = root[i+2] * prod % mod; irate2[i] = iroot[i+2] * iprod % mod; prod = prod * iroot[i+2] % mod\n\t\tiprod = iprod * root[i+2] % mod\n\t}\n\tprod,iprod = 1,1\n\tfor i:=0;i<=rank2-3;i++ {\n\t\trate3[i] = root[i+3] * prod % mod; irate3[i] = iroot[i+3] * iprod % mod; prod = prod * iroot[i+3] % mod\n\t\tiprod = iprod * root[i+3] % mod\n\t}\n\treturn &CONVOLVER{mod, primroot, rank2, root, iroot, rate2, irate2, rate3, irate3}\n}\nfunc (q *CONVOLVER) butterfly(a []int) {\n\tmod := q.mod; n := len(a); h := 0; for (1<<h) < n { h++ }; ll := 0\n\tfor ll < h {\n\t\tif (h - ll == 1) {\n\t\t\tp := 1 << (h-ll-1); rot := 1\n\t\t\tfor s:=0; s < (1 << ll); s++ {\n\t\t\t\toffset := s << (h - ll)\n\t\t\t\tfor i:=0;i<p;i++ {\n\t\t\t\t\tl := a[i+offset]; r := a[i+offset+p] * rot % mod; u := l + r; if u >= mod { u -= mod }\n\t\t\t\t\tv := l - r; if v < 0 { v += mod }; a[i+offset] = u; a[i+offset+p] = v\n\t\t\t\t}\n\t\t\t\tif s + 1 != (1 << ll) { rot = rot * q.rate2[bits.TrailingZeros(^uint(s))] % mod }\n\t\t\t}\n\t\t\tll++\n\t\t} else {\n\t\t\tp := 1 << (h-ll-2); rot := 1; imag := q.root[2]\n\t\t\tfor s:=0; s < (1 << ll); s++ {\n\t\t\t\trot2 := rot * rot % mod; rot3 := rot2 * rot % mod; offset := s << (h - ll)\n\t\t\t\tfor i:=0;i<p;i++ {\n\t\t\t\t\tmod2 := mod * mod; a0 := a[i+offset]; a1 := a[i+offset+p] * rot; a2 := a[i+offset+2*p] * rot2\n\t\t\t\t\ta3 := a[i+offset+3*p] * rot3; a1na3imag := (a1+mod2-a3) % mod * imag; na2 := mod2 - a2\n\t\t\t\t\ta[i+offset] = (a0 + a2 + a1 + a3) % mod; a[i+offset+p] = (a0 + a2 + (2 * mod2 - a1 - a3)) % mod\n\t\t\t\t\ta[i+offset+2*p] = (a0 + na2 + a1na3imag) % mod\n\t\t\t\t\ta[i+offset+3*p] = (a0 + na2 + (mod2-a1na3imag)) % mod\n\t\t\t\t}\n\t\t\t\tif s + 1 != (1 << ll) { rot = rot * q.rate3[bits.TrailingZeros(^uint(s))] % mod }\n\t\t\t}\n\t\t\tll += 2\n\t\t}\n\t}\n}\nfunc (q *CONVOLVER) butterflyinv(a []int) {\n\tmod := q.mod; n := len(a); h := 0; for (1<<h) < n { h++ }; ll := h\n\tfor ll > 0 {\n\t\tif (ll == 1) {\n\t\t\tp := 1 << (h-ll); irot := 1\n\t\t\tfor s:=0; s < (1 << (ll-1)); s++ {\n\t\t\t\toffset := s << (h - ll + 1)\n\t\t\t\tfor i:=0;i<p;i++ {\n\t\t\t\t\tl := a[i+offset]; r := a[i+offset+p]; u := l + r; if u >= mod { u -= mod }\n\t\t\t\t\tv := (mod+l-r) * irot % mod; a[i+offset] = u; a[i+offset+p] = v\n\t\t\t\t}\n\t\t\t\tif s + 1 != (1 << (ll-1)) { irot = irot * q.irate2[bits.TrailingZeros(^uint(s))] % mod }\n\t\t\t}\n\t\t\tll--\n\t\t} else {\n\t\t\tp := 1 << (h-ll); irot := 1; iimag := q.iroot[2]\n\t\t\tfor s:=0; s < (1 << (ll-2)); s++ {\n\t\t\t\tirot2 := irot * irot % mod; irot3 := irot2 * irot % mod; offset := s << (h - ll + 2)\n\t\t\t\tfor i:=0;i<p;i++ {\n\t\t\t\t\ta0 := a[i+offset]; a1 := a[i+offset+p]; a2 := a[i+offset+2*p]; a3 := a[i+offset+3*p]\n\t\t\t\t\ta2na3iimag := (mod + a2 - a3) * iimag % mod; a[i+offset] = (a0 + a1 + a2 + a3) % mod\n\t\t\t\t\ta[i+offset+p] = (a0 + (mod-a1) + a2na3iimag) * irot % mod\n\t\t\t\t\ta[i+offset+2*p] = (a0 + a1 + (mod-a2) + (mod-a3)) * irot2 % mod\n\t\t\t\t\ta[i+offset+3*p] = (a0 + (mod-a1) + (mod - a2na3iimag)) * irot3 % mod\n\t\t\t\t}\n\t\t\t\tif s + 1 != (1 << (ll-2)) { irot = irot * q.irate3[bits.TrailingZeros(^uint(s))] % mod }\n\t\t\t}\n\t\t\tll -= 2\n\t\t}\n\t}\n\tiz := CONVOLVERpowmod(n,mod-2,mod); for i:=0;i<n;i++ { a[i] = a[i] * iz % mod }\n}\nfunc (q *CONVOLVER) convolvefft(a []int, b []int) []int {\n\tmod := q.mod; finalsz := len(a) + len(b) - 1; z := 1; for z < finalsz { z *= 2 }; lena, lenb := len(a), len(b)\n\tla := make([]int, z); lb := make([]int, z); for i := 0; i < lena; i++ { la[i] = a[i] }\n\tfor i := 0; i < lenb; i++ { lb[i] = b[i] }; q.butterfly(la); q.butterfly(lb)\n\tfor i := 0; i < z; i++ { la[i] *= lb[i]; la[i] %= mod }; q.butterflyinv(la); return la[:finalsz]\n}\nfunc (q *CONVOLVER) convolvenaive(a []int, b []int) []int {\n\tmod := q.mod; finalsz := len(a) + len(b) - 1; ans := make([]int, finalsz)\n\tfor i,a := range a { for j,b := range b { ans[i+j] += a * b; ans[i+j] %= mod } }; return ans\n}\nfunc (q *CONVOLVER) Convolve(a []int, b []int) []int {\n\tlmin := len(a); if len(b) < lmin { lmin = len(b) }\n\tif lmin <= 60 { return q.convolvenaive(a,b) } else { return q.convolvefft(a,b) }\n}",
    "fenwick": "type Fenwick struct { n, tot int; bit []int }\nfunc NewFenwick(n int) *Fenwick { buf := make([]int, n+1); return &Fenwick{n, 0, buf} }\nfunc (q *Fenwick) Clear() { for i := 0; i <= q.n; i++ { q.bit[i] = 0 }; q.tot = 0 }\nfunc (q *Fenwick) Inc(idx int, val int) { for idx <= q.n { q.bit[idx] += val; idx += idx & (-idx) }; q.tot += val }\nfunc (q *Fenwick) Dec(idx int, val int) { q.Inc(idx, -val) }\nfunc (q *Fenwick) IncDec(left int, right int, val int) { q.Inc(left, val); q.Dec(right, val) }\nfunc (q *Fenwick) Prefixsum(idx int) int {\n\tif idx < 1 { return 0 }; ans := 0; for idx > 0 { ans += q.bit[idx]; idx -= idx & (-idx) }; return ans\n}\nfunc (q *Fenwick) Suffixsum(idx int) int { return q.tot - q.Prefixsum(idx-1) }\nfunc (q *Fenwick) Rangesum(left int, right int) int {\n\tif right < left { return 0 }; return q.Prefixsum(right) - q.Prefixsum(left-1)\n}",
    "maxflow": "type mfpreedge struct{ to, rev, cap int }\ntype mfedge struct{ from, to, cap, flow int }\ntype mfpos struct{ x, y int }\ntype Mfgraph struct { n int; pos []mfpos; g [][]mfpreedge }\nfunc NewMfgraph(n int) *Mfgraph { g := make([][]mfpreedge, n); pos := make([]mfpos, 0); return &Mfgraph{n, pos, g} }\nfunc (q *Mfgraph) Addedge(from, to, cap int) int {\n\tm := len(q.pos); fromid := len(q.g[from]); toid := len(q.g[to]); q.pos = append(q.pos, mfpos{from, fromid})\n\tif from == to { toid++ }; q.g[from] = append(q.g[from], mfpreedge{to, toid, cap})\n\tq.g[to] = append(q.g[to], mfpreedge{from, fromid, 0}); return m\n}\nfunc (q *Mfgraph) Getedge(i int) mfedge {\n\te := q.g[q.pos[i].x][q.pos[i].y]; re := q.g[e.to][e.rev]; return mfedge{q.pos[i].x, e.to, e.cap + re.cap, re.cap}\n}\nfunc (q *Mfgraph) Edges() []mfedge {\n\tm := len(q.pos); res := make([]mfedge, 0); for i := 0; i < m; i++ { res = append(res, q.Getedge(i)) }; return res\n}\nfunc (q *Mfgraph) Changeedge(i int, newcap int, newflow int) {\n\te := &(q.g[q.pos[i].x][q.pos[i].y]); re := &(q.g[e.to][e.rev]); e.cap = newcap - newflow; re.cap = newflow\n}\nfunc (q *Mfgraph) Flow(s, t int) int { return q.FlowCapped(s, t, 1000000000000000000) }\nfunc (q *Mfgraph) FlowCapped(s int, t int, flowlimit int) int {\n\tlevel := make([]int, q.n); iter := make([]int, q.n)\n\tbfs := func() {\n\t\tfor i := 0; i < q.n; i++ { level[i] = -1 }; level[s] = 0; que := make([]int, 0, q.n); que = append(que, s)\n\t\tfor len(que) > 0 {\n\t\t\tv := que[0]; que = que[1:]\n\t\t\tfor _, e := range q.g[v] {\n\t\t\t\tif e.cap == 0 || level[e.to] >= 0 { continue }; level[e.to] = level[v] + 1; if e.to == t { return }\n\t\t\t\tque = append(que, e.to)\n\t\t\t}\n\t\t}\n\t}\n\tvar dfs func(int, int) int\n\tdfs = func(v int, up int) int {\n\t\tif v == s { return up }; res := 0; level_v := level[v]\n\t\tfor i := iter[v]; i < len(q.g[v]); i++ {\n\t\t\te := q.g[v][i]; cap := q.g[e.to][e.rev].cap; if level_v <= level[e.to] || cap == 0 { continue }\n\t\t\tnewup := up - res; if cap < up-res { newup = cap }; d := dfs(e.to, newup); if d <= 0 { continue }\n\t\t\tq.g[v][i].cap += d; q.g[e.to][e.rev].cap -= d; res += d; if res == up { return res }\n\t\t}\n\t\tlevel[v] = q.n; return res\n\t}\n\tflow := 0\n\tfor flow < flowlimit {\n\t\tbfs(); if level[t] == -1 { break }; for i := 0; i < q.n; i++ { iter[i] = 0 }; f := dfs(t, flowlimit-flow)\n\t\tif f == 0 { break }; flow += f\n\t}\n\treturn flow\n}\nfunc (q *Mfgraph) Mincut(s int) []bool {\n\tvisited := make([]bool, q.n); que := make([]int, 0, q.n); que = append(que, s)\n\tfor len(que) > 0 {\n\t\tp := que[0]; que = que[1:]; visited[p] = true\n\t\tfor _, e := range q.g[p] { if e.cap > 0 && !visited[e.to] { visited[e.to] = true; que = append(que, e.to) } }\n\t}\n\treturn visited\n}",
    "matching": "type PI struct{ x, y int }\ntype hopcroftKarpQueue struct { buf []int; head, tail, sz, bm, l int }\nfunc NewhopcroftKarpQueue() *hopcroftKarpQueue { buf := make([]int, 8); return &hopcroftKarpQueue{buf, 0, 0, 8, 7, 0} }\nfunc (q *hopcroftKarpQueue) IsEmpty() bool { return q.l == 0 }\nfunc (q *hopcroftKarpQueue) Clear() { q.head = 0; q.tail = 0; q.l = 0 }\nfunc (q *hopcroftKarpQueue) Len() int { return q.l }\nfunc (q *hopcroftKarpQueue) Push(x int) {\n\tif q.l == q.sz { q.sizeup() }; if q.l > 0 { q.head = (q.head - 1) & q.bm }; q.l++; q.buf[q.head] = x\n}\nfunc (q *hopcroftKarpQueue) Pop() int {\n\tif q.l == 0 { panic(\"Empty hopcroftKarpQueue Pop()\") }; v := q.buf[q.tail]; q.l--\n\tif q.l > 0 { q.tail = (q.tail - 1) & q.bm } else { q.Clear() }; return v\n}\nfunc (q *hopcroftKarpQueue) Head() int { if q.l == 0 { panic(\"Empty hopcroftKarpQueue Head()\") }; return q.buf[q.head] }\nfunc (q *hopcroftKarpQueue) Tail() int { if q.l == 0 { panic(\"Empty hopcroftKarpQueue Tail()\") }; return q.buf[q.tail] }\nfunc (q *hopcroftKarpQueue) sizeup() {\n\tbuf := make([]int, 2*q.sz); for i := 0; i < q.l; i++ { buf[i] = q.buf[(q.head+i)&q.bm] }; q.buf = buf; q.head = 0\n\tq.tail = q.sz - 1; q.sz = 2 * q.sz; q.bm = q.sz - 1\n}\nfunc HopcroftKarp(N1, N2 int, adj [][]int) []PI {\n\tmynil := N1 + N2; pairu := make([]int, N1); pairv := make([]int, N2); dist := make([]int, N1+N2+1)\n\tmyinf := 1000000000000000000; q := NewhopcroftKarpQueue()\n\tbfs := func() bool {\n\t\tfor u := 0; u < N1; u++ { if pairu[u] == mynil { dist[u] = 0; q.Push(u) } else { dist[u] = myinf } }\n\t\tdist[mynil] = myinf\n\t\tfor !q.IsEmpty() {\n\t\t\tu := q.Pop()\n\t\t\tif u != mynil && dist[u] < dist[mynil] {\n\t\t\t\tfor _, v := range adj[u] { u2 := pairv[v]; if dist[u2] == myinf { dist[u2] = dist[u] + 1; q.Push(u2) } }\n\t\t\t}\n\t\t}\n\t\treturn dist[mynil] != myinf\n\t}\n\tvar dfs func(int) bool\n\tdfs = func(u int) bool {\n\t\tif u == mynil { return true }\n\t\tfor _, v := range adj[u] {\n\t\t\tu2 := pairv[v]; if dist[u2] == dist[u]+1 && dfs(u2) { pairv[v], pairu[u] = u, v; return true }\n\t\t}\n\t\tdist[u] = myinf; return false\n\t}\n\tfor i := 0; i < N1; i++ { pairu[i] = mynil }; for i := 0; i < N2; i++ { pairv[i] = mynil }\n\tfor bfs() { for u := 0; u < N1; u++ { if pairu[u] == mynil { dfs(u) } } }; res := make([]PI, 0)\n\tfor u := 0; u < N1; u++ { if pairu[u] != mynil { res = append(res, PI{u, pairu[u]}) } }; return res\n}",
    "dsu": "type Dsu struct { n int; parentOrSize []int }\nfunc NewDsu(n int) *Dsu { buf := make([]int, n); for i := 0; i < n; i++ { buf[i] = -1 }; return &Dsu{n, buf} }\nfunc (q *Dsu) Leader(a int) int {\n\tif q.parentOrSize[a] < 0 { return a }; ans := q.Leader(q.parentOrSize[a]); q.parentOrSize[a] = ans; return ans\n}\nfunc (q *Dsu) Merge(a int, b int) int {\n\tx := q.Leader(a); y := q.Leader(b); if x == y { return x }; if q.parentOrSize[y] < q.parentOrSize[x] { x, y = y, x }\n\tq.parentOrSize[x] += q.parentOrSize[y]; q.parentOrSize[y] = x; return x\n}\nfunc (q *Dsu) Same(a int, b int) bool { return q.Leader(a) == q.Leader(b) }\nfunc (q *Dsu) Size(a int) int { l := q.Leader(a); return -q.parentOrSize[l] }\nfunc (q *Dsu) Groups() [][]int {\n\tnumgroups := 0; leader2idx := make([]int, q.n); for i := 0; i <= q.n; i++ { leader2idx[i] = -1 }\n\tans := make([][]int, 0)\n\tfor i := int(0); i <= int(q.n); i++ {\n\t\tl := q.Leader(i)\n\t\tif leader2idx[l] == -1 { ans = append(ans, make([]int, 0)); leader2idx[l] = numgroups; numgroups += 1 }\n\t\tans[leader2idx[l]] = append(ans[leader2idx[l]], i)\n\t}\n\treturn ans\n}",
    "dsusparse": "type DsuSparse struct { n int; parentOrSize map[int]int }\nfunc NewDsuSparse() *DsuSparse { mm := make(map[int]int); return &DsuSparse{0, mm} }\nfunc (q *DsuSparse) Add(x int) { q.n++; q.parentOrSize[x] = -1 }\nfunc (q *DsuSparse) Leader(a int) int {\n\tif q.parentOrSize[a] < 0 { return a }; ans := q.Leader(q.parentOrSize[a]); q.parentOrSize[a] = ans; return ans\n}\nfunc (q *DsuSparse) Merge(a int, b int) int {\n\tx := q.Leader(a); y := q.Leader(b); if x == y { return x }; if q.parentOrSize[y] < q.parentOrSize[x] { x, y = y, x }\n\tq.parentOrSize[x] += q.parentOrSize[y]; q.parentOrSize[y] = x; return x\n}\nfunc (q *DsuSparse) Same(a int, b int) bool { return q.Leader(a) == q.Leader(b) }\nfunc (q *DsuSparse) Size(a int) int { l := q.Leader(a); return -q.parentOrSize[l] }\nfunc (q *DsuSparse) Groups() [][]int {\n\tnumgroups := 0; leader2idx := make(map[int]int); ans := make([][]int, 0)\n\tfor i := 0; i <= q.n; i++ {\n\t\tl := q.Leader(i); v, ok := leader2idx[l]\n\t\tif !ok { ans = append(ans, make([]int, 0)); leader2idx[l] = numgroups; v = numgroups; numgroups += 1 }\n\t\tans[v] = append(ans[v], i)\n\t}\n\treturn ans\n}",
    "mincostflow": "type MinCostFlowPI struct{ c, v int }\ntype MinHeapMinCostFlow struct { buf []MinCostFlowPI; less func(MinCostFlowPI, MinCostFlowPI) bool }\nfunc NewMinHeapMinCostFlow(f func(MinCostFlowPI, MinCostFlowPI) bool) *MinHeapMinCostFlow {\n\tbuf := make([]MinCostFlowPI, 0); return &MinHeapMinCostFlow{buf, f}\n}\nfunc (q *MinHeapMinCostFlow) IsEmpty() bool { return len(q.buf) == 0 }\nfunc (q *MinHeapMinCostFlow) Push(v MinCostFlowPI) { q.buf = append(q.buf, v); q.siftdown(0, len(q.buf)-1) }\nfunc (q *MinHeapMinCostFlow) Pop() MinCostFlowPI {\n\tv1 := q.buf[0]; l := len(q.buf)\n\tif l == 1 { q.buf = q.buf[:0] } else { l--; q.buf[0] = q.buf[l]; q.buf = q.buf[:l]; q.siftup(0) }; return v1\n}\nfunc (q *MinHeapMinCostFlow) siftdown(startpos, pos int) {\n\tnewitem := q.buf[pos]\n\tfor pos > startpos {\n\t\tppos := (pos - 1) >> 1; p := q.buf[ppos]; if !q.less(newitem, p) { break }; q.buf[pos], pos = p, ppos\n\t}\n\tq.buf[pos] = newitem\n}\nfunc (q *MinHeapMinCostFlow) siftup(pos int) {\n\tendpos, startpos, newitem, chpos := len(q.buf), pos, q.buf[pos], 2*pos+1\n\tfor chpos < endpos {\n\t\trtpos := chpos + 1; if rtpos < endpos && !q.less(q.buf[chpos], q.buf[rtpos]) { chpos = rtpos }\n\t\tq.buf[pos], pos = q.buf[chpos], chpos; chpos = 2*pos + 1\n\t}\n\tq.buf[pos] = newitem; q.siftdown(startpos, pos)\n}\ntype MinCostFlow struct { n, numedges int; g [][]int; to, cap, cost []int }\nfunc NewMinCostFlow(n int) *MinCostFlow {\n\tg := make([][]int, n); to := make([]int, 0); cap := make([]int, 0); cost := make([]int, 0)\n\treturn &MinCostFlow{n, 0, g, to, cap, cost}\n}\nfunc (q *MinCostFlow) AddEdge(fr, to, cap, cost int) {\n\tq.to = append(q.to, to); q.to = append(q.to, fr); q.cap = append(q.cap, cap); q.cap = append(q.cap, 0)\n\tq.cost = append(q.cost, cost); q.cost = append(q.cost, -cost); q.g[fr] = append(q.g[fr], q.numedges)\n\tq.g[to] = append(q.g[to], q.numedges+1); q.numedges += 2\n}\nfunc (q *MinCostFlow) Flowssp(s, t int) (int, int) {\n\tinf := 1000000000000000000; res := 0; h := make([]int, q.n); prv_v := make([]int, q.n); prv_e := make([]int, q.n)\n\tf := 0; dist := make([]int, q.n); for i := 0; i < q.n; i++ { dist[i] = inf }\n\tfor {\n\t\tfor i := 0; i < q.n; i++ { dist[i] = inf }; dist[s] = 0\n\t\tque := NewMinHeapMinCostFlow(func(a, b MinCostFlowPI) bool { return a.c < b.c }); que.Push(MinCostFlowPI{0, s})\n\t\tfor !que.IsEmpty() {\n\t\t\txx := que.Pop(); c, v := xx.c, xx.v; if dist[v] < c { continue }; r0 := dist[v] + h[v]\n\t\t\tfor _, e := range q.g[v] {\n\t\t\t\tw, cap, cost := q.to[e], q.cap[e], q.cost[e]\n\t\t\t\tif cap > 0 && r0+cost-h[w] < dist[w] {\n\t\t\t\t\tr := r0 + cost - h[w]; dist[w] = r; prv_v[w] = v; prv_e[w] = e; que.Push(MinCostFlowPI{r, w})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif dist[t] == inf { return f, res }; for i := 0; i < q.n; i++ { h[i] += dist[i] }; d := inf; v := t\n\t\tfor v != s { dcand := q.cap[prv_e[v]]; if dcand < d { d = dcand }; v = prv_v[v] }; f += d; res += d * h[t]\n\t\tv = t; for v != s { e := prv_e[v]; e2 := e ^ 1; q.cap[e] -= d; q.cap[e2] += d; v = prv_v[v] }\n\t}\n}",
    "scc": "type PI struct{ x, y int }\nfunc Kosaraju(n int, diredges []PI) (int, []int) {\n\tg, grev, visited, visitedInv, scc, s, counter := make([][]int, n), make([][]int, n), make([]bool, n), make([]bool, n), make([]int, n), make([]int, 0, n), 0\n\tvar dfs1, dfs2 func(int)\n\tfor _, xx := range diredges { x, y := xx.x, xx.y; g[x] = append(g[x], y); grev[y] = append(grev[y], x) }\n\tdfs1 = func(u int) { if !visited[u] { visited[u] = true; for _, c := range g[u] { dfs1(c) }; s = append(s, u) } }\n\tfor i := 0; i < n; i++ { dfs1(i) }\n\tdfs2 = func(u int) {\n\t\tif !visitedInv[u] { visitedInv[u] = true; for _, c := range grev[u] { dfs2(c) }; scc[u] = counter }\n\t}\n\tfor i := n - 1; i >= 0; i-- { nn := s[i]; if !visitedInv[nn] { dfs2(nn); counter += 1 } }; return counter, scc\n}",
    "twosat": "type PI struct{ x, y int }\nfunc Kosaraju(n int, diredges []PI) (int, []int) {\n\tg, grev, visited, visitedInv, scc, s, counter := make([][]int, n), make([][]int, n), make([]bool, n), make([]bool, n), make([]int, n), make([]int, 0, n), 0\n\tvar dfs1, dfs2 func(int)\n\tfor _, xx := range diredges { x, y := xx.x, xx.y; g[x] = append(g[x], y); grev[y] = append(grev[y], x) }\n\tdfs1 = func(u int) { if !visited[u] { visited[u] = true; for _, c := range g[u] { dfs1(c) }; s = append(s, u) } }\n\tfor i := 0; i < n; i++ { dfs1(i) }\n\tdfs2 = func(u int) {\n\t\tif !visitedInv[u] { visitedInv[u] = true; for _, c := range grev[u] { dfs2(c) }; scc[u] = counter }\n\t}\n\tfor i := n - 1; i >= 0; i-- { nn := s[i]; if !visitedInv[nn] { dfs2(nn); counter += 1 } }; return counter, scc\n}\ntype Twosat struct { n int; answer []bool; edgelist []PI }\nfunc NewTwosat(n int) *Twosat {\n\tanswer := make([]bool, n); edgelist := make([]PI, 0); return &Twosat{n, answer, edgelist}\n}\nfunc (q *Twosat) AddClause(i int, f bool, j int, g bool) {\n\tn1, n2, n3, n4 := 2*i, 2*j, 2*j, 2*i; if f { n4 += 1 } else { n1 += 1 }; if g { n2 += 1 } else { n3 += 1 }\n\tq.edgelist = append(q.edgelist, PI{n1, n2}); q.edgelist = append(q.edgelist, PI{n3, n4})\n}\nfunc (q *Twosat) Satisfiable() (bool, []bool) {\n\t_, id := Kosaraju(2*q.n, q.edgelist)\n\tfor i := 0; i < q.n; i++ { if id[2*i] == id[2*i+1] { return false, q.answer }; q.answer[i] = id[2*i] < id[2*i+1] }\n\treturn true, q.answer\n}",
    "bisect": "func bisect_left(arr []int, targ int) int {\n\tl, u := -1, len(arr); for u-l > 1 { m := (u + l) >> 1; if arr[m] < targ { l = m } else { u = m } }; return u\n}\nfunc bisect_right(arr []int, targ int) int {\n\tl, u := -1, len(arr); for u-l > 1 { m := (u + l) >> 1; if arr[m] <= targ { l = m } else { u = m } }; return u\n}",
    "bitset": "type Bitset struct { m int; c []uint64 }\nfunc NewBitset(cap int) *Bitset { return &Bitset{0, make([]uint64, 0, cap)} }\nfunc (q *Bitset) Copy() *Bitset {\n\tc2 := make([]uint64, len(q.c)); for i, x := range q.c { c2[i] = x }; return &Bitset{q.m, c2}\n}\nfunc (q *Bitset) Ins(n int) { for q.m <= n { q.c = append(q.c, 0); q.m += 64 }; q.c[n/64] |= 1 << uint(n % 64) }\nfunc (q *Bitset) Del(n int) { if q.m > n { q.c[n/64] &= 0xffffffffffffffff ^ (1 << uint(n % 64)) } }\nfunc (q *Bitset) Flip(n int) { for q.m <= n { q.c = append(q.c, 0); q.m += 64 }; q.c[n/64] ^= 1 << uint(n % 64) }\nfunc (q *Bitset) Size() int { return q.m }\nfunc (q *Bitset) Any() bool { for _, cc := range q.c { if cc != 0 { return true } }; return false }\nfunc (q *Bitset) None() bool { for _, cc := range q.c { if cc != 0 { return false } }; return true }\nfunc (q *Bitset) Count() int { ans := 0; for _, cc := range q.c { ans += bits.OnesCount64(cc) }; return ans }\nfunc (q *Bitset) PadTo(a *Bitset) { for q.m < a.m { q.c = append(q.c, 0); q.m += 64 } }\nfunc (q *Bitset) And(a *Bitset) {\n\tif a.m < q.m { q.shrinkTo(a.m) }; lq := len(q.c); for i := 0; i < lq; i++ { q.c[i] &= a.c[i] }\n}\nfunc (q *Bitset) Or(a *Bitset) { q.PadTo(a); la := len(a.c); for i := 0; i < la; i++ { q.c[i] |= a.c[i] } }\nfunc (q *Bitset) Xor(a *Bitset) { q.PadTo(a); la := len(a.c); for i := 0; i < la; i++ { q.c[i] ^= a.c[i] } }\nfunc (q *Bitset) Cap(n int) { q.shrinkTo(n) }\nfunc (q *Bitset) Not() { lc := len(q.c); for i := 0; i < lc; i++ { q.c[i] = ^q.c[i] } }\nfunc (q *Bitset) Shl(a int) {\n\tq.shrink(); if q.m == 0 { return }; mm := q.max() + 1; newmm := mm + a\n\tfor q.m < newmm { q.c = append(q.c, 0); q.m += 64 }; g, b := a/64, a%64\n\tfor i := len(q.c) - 1; i >= 0; i-- {\n\t\tif i-g < 0 {\n\t\t\tq.c[i] = 0\n\t\t} else {\n\t\t\tq.c[i] = q.c[i-g] << uint(b); if i-g-1 >= 0 && b != 0 { q.c[i] |= q.c[i-g-1] >> uint(64 - b) }\n\t\t}\n\t}\n}\nfunc (q *Bitset) Shr(a int) {\n\tg, b, lc := a/64, a%64, len(q.c)\n\tfor i := 0; i < lc; i++ {\n\t\tif i+g >= lc {\n\t\t\tq.c[i] = 0\n\t\t} else {\n\t\t\tq.c[i] = q.c[i+g] >> uint(b); if i+g+1 < lc && b != 0 { q.c[i] |= q.c[i+g+1] << uint(64 - b) }\n\t\t}\n\t}\n\tq.shrink()\n}\nfunc (q *Bitset) GetBits() []int {\n\tbase := 0; ans := []int{}\n\tfor _, c := range q.c {\n\t\tfor c != 0 { offset := bits.TrailingZeros64(c); ans = append(ans, base+offset); c ^= 1 << uint(offset) }\n\t\tbase += 64\n\t}\n\treturn ans\n}\nfunc (q *Bitset) shrink() { for i := len(q.c) - 1; i >= 0 && q.c[i] == 0; i-- { q.c = q.c[:i]; q.m -= 64 } }\nfunc (q *Bitset) shrinkTo(a int) { i := len(q.c) - 1; for q.m-64 > a { q.c = q.c[:i]; q.m -= 64 } }\nfunc (q *Bitset) max() int {\n\tlc := len(q.c); if q.c[lc-1] == 0 { q.shrink(); lc = len(q.c) }; if lc == 0 { return -1 }\n\treturn 64*lc - 1 - bits.LeadingZeros64(q.c[lc-1])\n}\nfunc BitsetAnd(a, b *Bitset) *Bitset { c := a.Copy(); c.And(b); return c }\nfunc BitsetOr(a, b *Bitset) *Bitset { c := a.Copy(); c.Or(b); return c }\nfunc BitsetXor(a, b *Bitset) *Bitset { c := a.Copy(); c.Xor(b); return c }\nfunc BitsetShl(a *Bitset, n int) *Bitset { c := a.Copy(); c.Shl(n); return c }\nfunc BitsetShr(a *Bitset, n int) *Bitset { c := a.Copy(); c.Shr(n); return c }",
    "crt": "func crtsafemod(x, m int) int { x %= m; if x < 0 { x += m }; return x }\nfunc crtinvgcd(a, b int) (int, int) {\n\ta = crtsafemod(a, b); if a == 0 { return b, 0 }; s, t, m0, m1 := b, a, 0, 1\n\tfor t != 0 { u := s / t; s -= t * u; m0 -= m1 * u; s, t, m0, m1 = t, s, m1, m0 }; if m0 < 0 { m0 += b / s }\n\treturn s, m0\n}\nfunc crt(r, m []int) (int, int) {\n\tif len(r) != len(m) { panic(\"Mismatched length in crt\") }\n\tfor _, mm := range m { if mm <= 0 { panic(\"CRT error -- non-positive modulus\") } }; n, r0, m0 := len(r), 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tr1, m1 := crtsafemod(r[i], m[i]), m[i]; if m0 < m1 { r0, r1, m0, m1 = r1, r0, m1, m0 }\n\t\tif m0%m1 == 0 { if r0%m1 != r1 { return 0, 0 }; continue }; g, im := crtinvgcd(m0, m1); u1 := m1 / g\n\t\tif (r1-r0)%g != 0 { return 0, 0 }; x := (r1 - r0) / g % u1 * im % u1; r0 += x * m0; m0 *= u1\n\t\tif r0 < 0 { r0 += m0 }\n\t}\n\treturn r0, m0\n}",
    "geo2d": "type Pt2 struct{ x, y int }\nfunc ptadd(a, b Pt2) Pt2 { return Pt2{a.x + b.x, a.y + b.y} }\nfunc ptsub(a, b Pt2) Pt2 { return Pt2{a.x - b.x, a.y - b.y} }\nfunc ptscale(n int, a Pt2) Pt2 { return Pt2{n * a.x, n * a.y} }\nfunc dot2(a, b Pt2) int { return a.x*b.x + a.y*b.y }\nfunc cross2(a, b Pt2) int { return a.x*b.y - a.y*b.x }\nfunc normsq2(a Pt2) int { return dot2(a, a) }\nfunc dot2b(orig, a, b Pt2) int { return dot2(ptsub(a, orig), ptsub(b, orig)) }\nfunc cross2b(orig, a, b Pt2) int { return cross2(ptsub(a, orig), ptsub(b, orig)) }\nfunc normsq2b(orig, a Pt2) int { x := ptsub(a, orig); return dot2(x, x) }\nfunc sortPt2xy(a []Pt2) {\n\tsort.Slice(a, func(i, j int) bool { return a[i].x < a[j].x || a[i].x == a[j].x && a[i].y < a[j].y })\n}\nfunc sortPt2yx(a []Pt2) {\n\tsort.Slice(a, func(i, j int) bool { return a[i].y < a[j].y || a[i].y == a[j].y && a[i].x < a[j].x })\n}\nfunc hullGraham(a []Pt2) ([]Pt2, bool) {\n\tn := len(a); if n < 3 { return []Pt2{}, false }; m := 0\n\tfor i := 1; i < n; i++ { if a[i].y < a[m].y || a[i].y == a[m].y && a[i].x < a[m].x { m = i } }\n\tcand := make([]int, 0, n-1); for i := 0; i < n; i++ { if i != m { cand = append(cand, i) } }\n\tsort.Slice(cand, func(i, j int) bool {\n\t\tx := cross2b(a[m], a[cand[i]], a[cand[j]])\n\t\treturn x > 0 || x == 0 && normsq2b(a[m], a[cand[i]]) < normsq2b(a[m], a[cand[j]])\n\t})\n\tC := []int{m}; l := 1\n\tfor _, c := range cand {\n\t\tfor l > 1 && cross2b(a[C[l-2]], a[C[l-1]], a[c]) <= 0 { C = C[:l]; l-- }; C = append(C, c); l++\n\t}\n\tans := make([]Pt2, l); for i := 0; i < l; i++ { ans[i] = a[C[i]] }; return ans, true\n}\nfunc hullMonotoneChain(a []Pt2) ([]Pt2, bool) {\n\tn := len(a); if n < 3 { return []Pt2{}, false }; p := make([]int, len(a)); for i := 0; i < n; i++ { p[i] = i }\n\tu := []int{}; l := []int{}\n\tsort.Slice(p, func(i, j int) bool { return a[p[i]].x < a[p[j]].x || a[p[i]].x == a[p[j]].x && a[p[i]].y < a[p[j]].y })\n\tss := 0\n\tfor _, i := range p {\n\t\tfor ss > 1 && cross2b(a[u[ss-2]], a[u[ss-1]], a[i]) >= 0 { u = u[:ss]; ss-- }; u = append(u, i); ss++\n\t}\n\tss = 0\n\tfor _, i := range p {\n\t\tfor ss > 1 && cross2b(a[l[ss-2]], a[l[ss-1]], a[i]) <= 0 { l = l[:ss]; ss-- }; l = append(u, i); ss++\n\t}\n\tans := make([]Pt2, 0); for _, xx := range l { ans = append(ans, a[xx]) }\n\tfor i := len(u) - 2; i >= 1; i-- { ans = append(ans, a[u[i]]) }; return ans, true\n}"
}